Script Name: Liquidity Levels-Voids (VP) [LuxAlgo]
Author: LuxAlgo
Description: The  Liquidity Levels/Voids (VP)  is a script designed to detect liquidity voids & levels by measuring traded volume at all price levels on the market between two swing points and highlighting the distribution of the liquidity voids & levels at specific price levels. 

 ğŸ”¶ USAGE 

  

Liquidity is a fundamental market force that shapes the trajectory of...
PineScript code:

Pine Scriptâ„¢ indicator
Liquidity Levels/Voids (VP) [LuxAlgo]
Copy code
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
//Â ThisÂ workÂ isÂ licensedÂ underÂ aÂ Attribution-NonCommercial-ShareAlikeÂ 4.0Â InternationalÂ (CCÂ BY-NC-SAÂ 4.0)Â https://creativecommons.org/licenses/by-nc-sa/4.0/
//Â Â©Â LuxAlgo
Â 
//@version=5
indicator("LiquidityÂ Levels/VoidsÂ (VP)Â [LuxAlgo]",Â "LuxAlgoÂ -Â LiquidityÂ Levels/VoidsÂ (VP)",Â true,Â max_bars_backÂ =Â 5000,Â max_boxes_countÂ =Â 500)Â //Â ,Â max_labels_countÂ =Â 500,Â max_lines_countÂ =Â 500
//------------------------------------------------------------------------------
//Â Settings
//-----------------------------------------------------------------------------{
mdTTÂ =Â 'TheÂ modeÂ optionÂ controlsÂ theÂ numberÂ ofÂ visualÂ objectsÂ presented,Â where\n\n-Â Historical,Â takesÂ intoÂ accountÂ allÂ dataÂ availableÂ toÂ theÂ user\n-Â Present,Â takesÂ intoÂ accountÂ onlyÂ theÂ lastÂ XÂ barsÂ specifiedÂ inÂ theÂ \'#Â Bars\'Â option\n\nPossibleÂ \'#Â Bars\'Â valuesÂ [100-5000]'
modeÂ =Â input.string('Present',Â titleÂ =Â 'Mode',Â optionsÂ =['Present',Â 'Historical'],Â inlineÂ =Â 'MOD')
backÂ =Â input.intÂ Â Â (360,Â 'Â #Â Bars',Â minvalÂ =Â 100,Â maxvalÂ =Â 5000,Â stepÂ =Â 10,Â inlineÂ =Â 'MOD',Â tooltipÂ =Â mdTT)
grpLQÂ =Â 'LiquidityÂ LevelsÂ /Â Voids'
liqUCÂ =Â input.color(color.new(#1848cc,Â 79),Â 'LiquidityÂ Levels/Voids',Â inlineÂ =Â 'UFL',Â groupÂ =Â grpLQ,Â tooltipÂ =Â 'ColorÂ customizationÂ optionÂ forÂ UnfilledÂ LiquidityÂ Levels/Voids')
ppLenÂ =Â input.int(47,Â "DetectionÂ Length",Â minvalÂ =Â 1,Â groupÂ =Â grpLQ,Â tooltipÂ =Â 'LookbackÂ periodÂ usedÂ forÂ theÂ calculationÂ ofÂ SwingÂ Levels\n\nMinimumÂ valueÂ [1]')
liqTÂ Â =Â input.int(21,Â 'ThresholdÂ %',Â minvalÂ =Â 1,Â maxvalÂ =Â 51,Â groupÂ =Â grpLQ,Â tooltipÂ =Â 'ThresholdÂ usedÂ forÂ theÂ calculationÂ ofÂ theÂ LiquidityÂ LevelsÂ &Â Voids\n\nPossibleÂ valuesÂ [1-51]')Â /Â 100
vpLevÂ =Â input.int(27,Â 'Sensitivity'Â ,Â minvalÂ =Â 10,Â maxvalÂ =Â 100,Â stepÂ =Â 1,Â groupÂ =Â grpLQ,Â tooltipÂ =Â 'AdjustsÂ theÂ numberÂ ofÂ levelsÂ betweenÂ twoÂ swingÂ points,Â asÂ aÂ result,Â theÂ heightÂ ofÂ aÂ levelÂ isÂ determinedÂ andÂ thenÂ basedÂ onÂ theÂ above-givenÂ thresholdÂ theÂ levelÂ isÂ checkedÂ ifÂ itÂ matchesÂ theÂ liquidityÂ level/voidÂ conditions\n\nPossibleÂ valuesÂ [10-100]')
liqFDÂ =Â input.bool(false,Â 'FilledÂ LiquidityÂ Levels/Voids',Â inlineÂ =Â 'FL',Â groupÂ =Â grpLQ,Â tooltipÂ =Â 'TogglesÂ theÂ visibilityÂ ofÂ theÂ FilledÂ LiquidityÂ Levels/VoidsÂ andÂ colorÂ customizationÂ optionÂ forÂ FilledÂ LiquidityÂ Levels/Voids')
liqFCÂ =Â input.color(color.new(#787b86,Â 79),Â '',Â inlineÂ =Â 'FL',Â groupÂ =Â grpLQ)
othGRÂ =Â 'OtherÂ Features'
ppLevÂ =Â input.bool(false,Â 'SwingÂ Highs/Lows',Â inlineÂ =Â 'ppLS',Â groupÂ =Â othGR,Â tooltipÂ =Â 'TogglesÂ theÂ visibilityÂ ofÂ theÂ SwingÂ Levels,Â whereÂ tooltipsÂ presentÂ statisticalÂ information,Â suchÂ asÂ price,Â priceÂ change,Â andÂ cumulativeÂ volumeÂ betweenÂ theÂ twoÂ swingÂ levelsÂ detectedÂ basedÂ onÂ theÂ detectionÂ lengthÂ specifiedÂ above\n\nColoringÂ optionsÂ toÂ customizeÂ swingÂ lowÂ andÂ swingÂ highÂ labelÂ colorsÂ andÂ SizeÂ optionÂ toÂ adjustÂ theÂ sizeÂ ofÂ theÂ labels')
ppLCBÂ =Â input.color(color.new(#f23645,Â 0),Â '',Â inlineÂ =Â 'ppLS',Â groupÂ =Â othGR)
ppLCSÂ =Â input.color(color.new(#089981,Â 0),Â '',Â inlineÂ =Â 'ppLS',Â groupÂ =Â othGR)
ppLSÂ Â =Â input.string('Small',Â "",Â options=['Tiny',Â 'Small',Â 'Normal'],Â inlineÂ =Â 'ppLS',Â groupÂ =Â othGR)
//-----------------------------------------------------------------------------}
//Â UserÂ DefinedÂ Types
//-----------------------------------------------------------------------------{
//Â @typeÂ Â Â Â Â Â Â Â barÂ propertiesÂ withÂ theirÂ valuesÂ 
//
//Â @fieldÂ hÂ Â Â Â Â (float)Â highÂ priceÂ ofÂ theÂ bar
//Â @fieldÂ lÂ Â Â Â Â (float)Â lowÂ priceÂ ofÂ theÂ bar
//Â @fieldÂ vÂ Â Â Â Â (float)Â volumeÂ ofÂ theÂ bar
//Â @fieldÂ iÂ Â Â Â Â (int)Â Â Â indexÂ ofÂ theÂ bar
typeÂ bar
Â Â Â Â floatÂ hÂ =Â high
Â Â Â Â floatÂ lÂ =Â low
Â Â Â Â floatÂ vÂ =Â volume
Â Â Â Â intÂ Â Â iÂ =Â bar_index
//Â @typeÂ Â Â Â Â Â Â Â storeÂ pivotÂ high/lowÂ andÂ indexÂ dataÂ 
//
//Â @fieldÂ xÂ Â Â Â Â (int)Â Â Â Â lastÂ pivotÂ barÂ index
//Â @fieldÂ x1Â Â Â Â (int)Â Â Â Â previousÂ pivotÂ barÂ index
//Â @fieldÂ hÂ Â Â Â Â (float)Â Â lastÂ pivotÂ high
//Â @fieldÂ h1Â Â Â Â (float)Â Â previousÂ pivotÂ high
//Â @fieldÂ lÂ Â Â Â Â (float)Â Â lastÂ pivotÂ low
//Â @fieldÂ l1Â Â Â Â (float)Â Â previousÂ pivotÂ low
typeÂ pivotPoint
Â Â Â Â intÂ Â Â Â x
Â Â Â Â intÂ Â Â Â x1
Â Â Â Â floatÂ Â h
Â Â Â Â floatÂ Â h1
Â Â Â Â floatÂ Â l
Â Â Â Â floatÂ Â l1
//Â @typeÂ Â Â Â Â Â Â Â maintainÂ liquidityÂ dataÂ 
//
//Â @fieldÂ bÂ Â Â Â Â (array<bool>)Â arrayÂ maintainsÂ priceÂ levelsÂ whereÂ liquidityÂ exists
//Â @fieldÂ bxÂ Â Â Â (array<box>)Â Â arrayÂ maintainsÂ visualÂ objectÂ ofÂ priceÂ levelsÂ whereÂ liquidityÂ exists
typeÂ liquidity
Â Â Â Â boolÂ []Â b
Â Â Â Â boxÂ Â []Â bx
//Â @typeÂ Â Â Â Â Â Â Â maintainÂ volumeÂ profileÂ dataÂ 
//
//Â @fieldÂ vsÂ Â Â Â (array<float>)Â arrayÂ maintainsÂ tolalÂ tradedÂ volume
//Â @fieldÂ vpÂ Â Â Â (array<box>)Â Â Â arrayÂ maintainsÂ visualÂ objectÂ ofÂ eachÂ priceÂ level
typeÂ volumeProfile
Â Â Â Â floatÂ []Â vs
Â Â Â Â boxÂ Â Â []Â vp
//-----------------------------------------------------------------------------}
//Â Variables
//-----------------------------------------------------------------------------{
barÂ bÂ =Â bar.new()
varÂ pivotPointÂ ppÂ =Â pivotPoint.new()
varÂ liquidity[]Â aLIQÂ =Â array.new<liquidity>Â (1,Â liquidity.new(array.newÂ <bool>Â (vpLev,Â false),Â array.newÂ <box>Â (na)))
varÂ liquidity[]Â dLIQÂ =Â array.new<liquidity>Â (1,Â liquidity.new(array.newÂ <bool>Â (na)Â Â Â Â Â Â Â Â Â Â ,Â array.newÂ <box>Â (na)))
volumeProfileÂ aVPÂ Â =Â volumeProfile.new(array.newÂ <float>Â (vpLevÂ +Â 1,Â 0.),Â array.newÂ <box>Â (na))
qBXsÂ =Â 0
//-----------------------------------------------------------------------------}
//Â Functions/methods
//-----------------------------------------------------------------------------{
//Â @functionÂ Â Â Â Â Â Â Â calcuatesÂ highestÂ price,Â lowestÂ priceÂ andÂ cumulativeÂ volumeÂ ofÂ theÂ givenÂ range
//Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
//Â @paramÂ _lÂ Â Â Â Â Â Â Â (int)Â Â lengthÂ ofÂ theÂ range
//Â @paramÂ _cÂ Â Â Â Â Â Â Â (bool)Â check
//Â @paramÂ _oÂ Â Â Â Â Â Â Â (int)Â Â offsetÂ 
//
//Â @returnsÂ Â Â Â Â Â Â Â Â (float,Â float,Â float)Â highest,Â lowestÂ andÂ cumulativeÂ volume
f_calcHLV(_l,Â _c,Â _o)Â =>
Â Â Â Â ifÂ _c
Â Â Â Â Â Â Â Â lÂ =Â lowÂ [_o]
Â Â Â Â Â Â Â Â hÂ =Â high[_o]
Â Â Â Â Â Â Â Â vÂ Â =Â 0.
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â forÂ xÂ =Â 0Â toÂ _lÂ -Â 1
Â Â Â Â Â Â Â Â Â Â Â Â lÂ :=Â math.min(lowÂ [_oÂ +Â x],Â l)
Â Â Â Â Â Â Â Â Â Â Â Â hÂ :=Â math.max(high[_oÂ +Â x],Â h)
Â Â Â Â Â Â Â Â Â Â Â Â vÂ +=Â volume[_oÂ +Â x]
Â Â Â Â Â Â Â Â lÂ :=Â math.min(lowÂ [_oÂ +Â _l],Â l)
Â Â Â Â Â Â Â Â hÂ :=Â math.max(high[_oÂ +Â _l],Â h)
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â [h,Â l,Â v]
//-----------------------------------------------------------------------------}
//Â Calculations
//-----------------------------------------------------------------------------{
perÂ Â =Â modeÂ ==Â 'Present'Â ?Â last_bar_indexÂ -Â b.iÂ <=Â backÂ :Â true
nzVÂ Â =Â nz(b.v)
ppSÂ =Â switchÂ ppLS
Â Â Â Â 'Tiny'Â Â Â =>Â size.tiny
Â Â Â Â 'Small'Â Â =>Â size.small
Â Â Â Â 'Normal'Â =>Â size.normal
pp_hÂ =Â ta.pivothigh(ppLen,Â ppLen)
pp_lÂ =Â ta.pivotlowÂ (ppLen,Â ppLen)
ifÂ notÂ na(pp_h)
Â Â Â Â pp.h1Â :=Â pp.h
Â Â Â Â pp.hÂ Â :=Â pp_h
ifÂ notÂ na(pp_l)
Â Â Â Â pp.l1Â :=Â pp.l
Â Â Â Â pp.lÂ Â :=Â pp_l
goÂ =Â notÂ na(pp_h)Â orÂ notÂ na(pp_l)Â 
ifÂ goÂ 
Â Â Â Â pp.x1Â :=Â pp.x
Â Â Â Â pp.xÂ Â :=Â b.i
vpLenÂ =Â pp.xÂ -Â pp.x1
[pHst,Â pLst,Â tV]Â =Â f_calcHLV(vpLen,Â go,Â ppLen)
pStpÂ =Â (pHstÂ -Â pLst)Â /Â vpLev
ifÂ goÂ andÂ nzVÂ andÂ pStpÂ >Â 0Â andÂ b.iÂ >Â vpLenÂ andÂ vpLenÂ >Â 0Â andÂ per
Â Â Â Â forÂ bItÂ =Â vpLenÂ toÂ 1
Â Â Â Â Â Â Â Â lÂ =Â 0
Â Â Â Â Â Â Â Â bIÂ =Â bItÂ +Â ppLen
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â forÂ pLevÂ =Â pLstÂ toÂ pHstÂ byÂ pStp
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ b.h[bI]Â >=Â pLevÂ andÂ b.l[bI]Â <Â pLevÂ +Â pStp
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â aVP.vs.set(l,Â aVP.vs.get(l)Â +Â nzV[bI]Â *Â ((b.h[bI]Â -Â b.l[bI])Â ==Â 0Â ?Â 1Â :Â pStpÂ /Â (b.h[bI]Â -Â b.l[bI])))
Â Â Â Â Â Â Â Â Â Â Â Â lÂ +=Â 1
Â Â Â Â aLIQ.unshift(liquidity.new(array.newÂ <bool>Â (vpLev,Â false),Â array.newÂ <box>Â (na)))
Â Â Â Â cLIQÂ =Â aLIQ.get(0)
Â Â Â Â forÂ lÂ =Â vpLevÂ -Â 1Â toÂ 0
Â Â Â Â Â Â Â Â ifÂ aVP.vs.get(l)Â /Â aVP.vs.max()Â <Â liqT
Â Â Â Â Â Â Â Â Â Â Â Â cLIQ.b.set(l,Â true)
Â Â Â Â Â Â Â Â Â Â Â Â cLIQ.bx.unshift(box.new(b.i[ppLen],Â pLstÂ +Â (lÂ +Â 0.00)Â *Â pStp,Â b.i[ppLen],Â pLstÂ +Â (lÂ +Â 1.00)Â *Â pStp,Â border_colorÂ =Â color(na),Â bgcolorÂ =Â liqUCÂ ))
Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â cLIQ.bx.unshift(box.new(na,Â na,Â na,Â na))
Â Â Â Â Â Â Â Â Â Â Â Â cLIQ.b.set(l,Â false)
Â Â Â Â forÂ bItÂ =Â 0Â toÂ vpLen
Â Â Â Â Â Â Â Â bIÂ =Â bItÂ +Â ppLen
Â Â Â Â Â Â Â Â intÂ qBXÂ =Â cLIQ.bx.size()
Â Â Â Â Â Â Â Â forÂ bxÂ =Â 0Â toÂ (qBXÂ >Â 0Â ?Â qBXÂ -Â 1Â :Â na)
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ bxÂ <Â cLIQ.bx.size()
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ cLIQ.b.get(bx)Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cBXÂ =Â cLIQ.bx.get(bx)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â mBXÂ =Â math.avg(cBX.get_bottom(),Â cBX.get_top())
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ math.sign(close[bIÂ +Â 1]Â -Â mBX)Â !=Â math.sign(low[bI]Â -Â mBX)Â orÂ math.sign(close[bIÂ +Â 1]Â -Â mBX)Â !=Â math.sign(high[bI]Â -Â mBX)Â orÂ math.sign(close[bIÂ +Â 1]Â -Â mBX)Â !=Â math.sign(close[bI]Â Â -Â mBX)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cBX.set_left(b.i[bI])
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cLIQ.b.set(bx,Â false)
Â Â Â Â forÂ bIÂ =Â ppLenÂ toÂ 0
Â Â Â Â Â Â Â Â intÂ qBXÂ =Â cLIQ.bx.size()
Â Â Â Â Â Â Â Â forÂ bxÂ =Â (qBXÂ >Â 0Â ?Â qBXÂ -Â 1Â :Â na)Â toÂ 0
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ bxÂ <Â cLIQ.bx.size()
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cBXÂ =Â cLIQ.bx.get(bx)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â mBXÂ =Â math.avg(box.get_bottom(cBX),Â box.get_top(cBX))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ math.sign(close[bIÂ +Â 1]Â -Â mBX)Â !=Â math.sign(low[bI]Â -Â mBX)Â orÂ math.sign(close[bIÂ +Â 1]Â -Â mBX)Â !=Â math.sign(high[bI]Â -Â mBX)Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ liqFD
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cBX.set_bgcolor(liqFC)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cBX.delete()
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cLIQ.bx.remove(bx)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cBX.set_right(b.i[bI])
forÂ iÂ =Â aLIQ.size()Â -Â 1Â toÂ 0
Â Â Â Â xÂ =Â aLIQ.get(i)
Â Â Â Â intÂ qBXÂ =Â x.bx.size()
Â Â Â Â qBXsÂ :=Â qBXsÂ +Â qBX
Â Â Â Â ifÂ qBXsÂ >Â 500
Â Â Â Â Â Â Â Â aLIQ.pop()
Â Â Â Â Â Â Â Â 
Â Â Â Â forÂ bxÂ =Â (qBXÂ >Â 0Â ?Â qBXÂ -Â 1Â :Â na)Â toÂ 0
Â Â Â Â Â Â Â Â ifÂ bxÂ <Â x.bx.size()
Â Â Â Â Â Â Â Â Â Â Â Â cBXÂ =Â x.bx.get(bx)
Â Â Â Â Â Â Â Â Â Â Â Â mBXÂ =Â math.avg(box.get_bottom(cBX),Â box.get_top(cBX))
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ math.sign(close[1]Â -Â mBX)Â !=Â math.sign(lowÂ -Â mBX)Â orÂ math.sign(close[1]Â -Â mBX)Â !=Â math.sign(highÂ -Â mBX)Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â //cBX.delete()
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ liqFD
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cBX.set_bgcolor(liqFC)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cBX.delete()
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â x.bx.remove(bx)
Â Â Â Â Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cBX.set_right(b.i)
ifÂ ppLevÂ andÂ (modeÂ ==Â 'Present'Â ?Â last_bar_indexÂ -Â b.iÂ <=Â backÂ *Â 1.318Â :Â true)
Â Â Â Â statTipÂ =Â '\nÂ -TradedÂ VolumeÂ :Â 'Â +Â str.tostring(tV,Â format.volume)Â +Â 'Â ('Â +Â str.tostring(vpLenÂ -Â 1)Â +Â 'Â bars)\nÂ Â *AverageÂ Volume/BarÂ :Â 'Â +Â str.tostring(tVÂ /Â (vpLenÂ -Â 1),Â format.volume)
Â Â Â Â ifÂ notÂ na(pp_h)
Â Â Â Â Â Â Â Â swHÂ =Â pp.hÂ >Â pp.h1Â ?Â "HH"Â :Â pp.hÂ <Â pp.h1Â ?Â "LH"Â :Â na
Â Â Â Â Â Â Â Â label.new(b.i[ppLen],Â pp.h,Â swH,Â xloc.bar_index,Â yloc.price,Â color(na),Â label.style_label_down,Â ppLCS,Â ppS,Â text.align_center,Â 'SwingÂ HighÂ :Â 'Â +Â str.tostring(pp.h,Â format.mintick)Â +Â '\nÂ -PriceÂ ChangeÂ :Â %'Â +Â str.tostring((pp.hÂ -Â pp.l)Â *Â 100Â /Â pp.l,Â '#.##')Â +Â statTip)
Â Â Â Â ifÂ notÂ na(pp_l)
Â Â Â Â Â Â Â Â swLÂ =Â pp.lÂ <Â pp.l1Â ?Â "LL"Â :Â pp.lÂ >Â pp.l1Â ?Â "HL"Â :Â na
Â Â Â Â Â Â Â Â label.new(b.i[ppLen],Â pp.lÂ ,swL,Â xloc.bar_index,Â yloc.price,Â color(na),Â label.style_label_upÂ Â ,Â ppLCB,Â ppS,Â text.align_center,Â 'SwingÂ LowÂ :Â 'Â Â +Â str.tostring(pp.l,Â format.mintick)Â +Â '\nÂ -PriceÂ ChangeÂ :Â %'Â +Â str.tostring((pp.hÂ -Â pp.l)Â *Â 100Â /Â pp.h,Â '#.##')Â +Â statTip)
vpLenÂ :=Â barstate.islastÂ ?Â last_bar_indexÂ -Â pp.xÂ +Â ppLenÂ Â :Â 1
pHstÂ Â :=Â ta.highest(b.h,Â vpLenÂ >Â 0Â ?Â vpLenÂ +Â 1Â :Â 1)
pLstÂ Â :=Â ta.lowestÂ (b.l,Â vpLenÂ >Â 0Â ?Â vpLenÂ +Â 1Â :Â 1)
pStpÂ Â :=Â (pHstÂ -Â pLst)Â /Â vpLev
ifÂ barstate.islastÂ andÂ nzVÂ andÂ vpLenÂ >Â 0Â andÂ pStpÂ >Â 0
Â Â Â Â tLIQÂ =Â dLIQ.shift()
Â Â Â Â ifÂ tLIQ.bx.size()Â >Â 0
Â Â Â Â Â Â Â Â forÂ iÂ =Â 0Â toÂ tLIQ.bx.size()Â -Â 1
Â Â Â Â Â Â Â Â Â Â Â Â tLIQ.bx.shift().delete()
Â Â Â Â Â Â Â Â tLIQ.b.shift()
Â Â Â Â forÂ bIÂ =Â vpLenÂ toÂ 1Â //1Â toÂ vpLen
Â Â Â Â Â Â Â Â lÂ =Â 0
Â Â Â Â Â Â Â Â forÂ pLevÂ =Â pLstÂ toÂ pHstÂ byÂ pStp
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ b.h[bI]Â >=Â pLevÂ andÂ b.l[bI]Â <Â pLevÂ +Â pStp
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â aVP.vs.set(l,Â aVP.vs.get(l)Â +Â nzV[bI]Â *Â ((b.h[bI]Â -Â b.l[bI])Â ==Â 0Â ?Â 1Â :Â pStpÂ /Â (b.h[bI]Â -Â b.l[bI])))
Â Â Â Â Â Â Â Â Â Â Â Â lÂ +=Â 1
Â Â Â Â 
Â Â Â Â dLIQ.unshift(liquidity.new(array.newÂ <bool>Â (na),Â array.newÂ <box>Â (na)))
Â Â Â Â cLIQÂ =Â dLIQ.get(0)
Â Â Â Â forÂ lÂ =Â 0Â toÂ vpLevÂ -Â 1
Â Â Â Â Â Â Â Â ifÂ aVP.vs.get(l)Â /Â aVP.vs.max()Â <Â liqT
Â Â Â Â Â Â Â Â Â Â Â Â cLIQ.b.unshift(true)
Â Â Â Â Â Â Â Â Â Â Â Â cLIQ.bx.unshift(box.new(b.i,Â pLstÂ +Â (lÂ +Â 0.00)Â *Â pStp,Â b.i,Â pLstÂ +Â (lÂ +Â 1.00)Â *Â pStp,Â border_colorÂ =Â color(na),Â bgcolorÂ =Â liqUC))
Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â cLIQ.bx.unshift(box.new(na,Â na,Â na,Â na))
Â Â Â Â Â Â Â Â Â Â Â Â cLIQ.b.unshift(false)
Â Â Â Â forÂ bIÂ =Â 0Â toÂ vpLen
Â Â Â Â Â Â Â Â intÂ qBXÂ =Â cLIQ.bx.size()
Â Â Â Â Â Â Â Â forÂ bxÂ =Â 0Â toÂ (qBXÂ >Â 0Â ?Â qBXÂ -Â 1Â :Â na)
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ bxÂ <Â cLIQ.bx.size()
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ cLIQ.b.get(bx)Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cBXÂ =Â cLIQ.bx.get(bx)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â mBXÂ =Â math.avg(cBX.get_bottom(),Â cBX.get_top())
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ math.sign(close[bIÂ +Â 1]Â -Â mBX)Â !=Â math.sign(low[bI]Â -Â mBX)Â orÂ math.sign(close[bIÂ +Â 1]Â -Â mBX)Â !=Â math.sign(high[bI]Â -Â mBX)Â orÂ math.sign(close[bIÂ +Â 1]Â -Â mBX)Â !=Â math.sign(close[bI]Â Â -Â mBX)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cBX.set_left(b.i[bI])
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cLIQ.b.set(bx,Â false)
Â //-----------------------------------------------------------------------------}
Expand (291 lines)